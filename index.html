<!DOCTYPE html>
<html>
<head>
    <title>BlockLang IDE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/codemirror.min.css">
    <style>
        body { margin: 0; padding: 20px; font-family: Arial; }
        #editor { border: 2px solid #ccc; margin-bottom: 10px; }
        #runBtn { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; }
        #output { margin-top: 20px; border: 1px solid #ccc; padding: 10px; min-height: 200px; position: relative; }
        .block { width: 50px; height: 50px; background: #2196F3; position: absolute; transition: all 1s ease; }
        .one-block { border: 2px solid #000; }
        #console { margin-top: 10px; padding: 10px; background: #000; color: #fff; min-height: 100px; }
    </style>
</head>
<body>
    <div id="editor"></div>
    <button id="runBtn">▶ Запустить</button>
    <div id="output">
        <div id="blocks"></div>
        <div id="console"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/mode/clike/clike.min.js"></script>
    <script>
        const editor = CodeMirror(document.getElementById('editor'), {
            mode: 'text/x-csrc',
            lineNumbers: true,
            theme: 'default',
            value: `add - block
block.color(100, 200, 50)
add - one.block(1)
one.block.position(40, 10)
one.block.color(255, 200, 0)
end)`
        });

        class Block {
            constructor() {
                this.element = document.createElement('div');
                this.element.className = 'block';
                this.x = 0;
                this.y = 0;
                this.lastMove = { dx: 0, dy: 0 };
                this.updatePosition();
                document.getElementById('blocks').appendChild(this.element);
            }

            updatePosition() {
                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            async moveOut(dx, dy, duration = 1) {
                this.lastMove = { dx, dy };
                this.x += dx;
                this.y += dy;
                this.element.style.transition = `all ${duration}s ease`;
                this.updatePosition();
                return new Promise(resolve => setTimeout(resolve, duration * 1000));
            }

            setColor(r, g, b) {
                const valid = [r, g, b].every(n => n >=0 && n <= 255);
                if (!valid) throw new Error('Некорректные значения цвета (0-255)');
                this.element.style.backgroundColor = `rgb(${r},${g},${b})`;
            }
        }

        class OneBlock {
            constructor(number) {
                this.number = number;
                this.element = document.createElement('div');
                this.element.className = 'block one-block';
                this.x = 0;
                this.y = 0;
                this.updatePosition();
                document.getElementById('blocks').appendChild(this.element);
            }

            updatePosition() {
                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                this.updatePosition();
            }

            setColor(r, g, b) {
                const valid = [r, g, b].every(n => n >=0 && n <= 255);
                if (!valid) throw new Error('Некорректные значения цвета (0-255)');
                this.element.style.backgroundColor = `rgb(${r},${g},${b})`;
            }
        }

        class ErrorSystem {
            constructor() {
                this.console = document.getElementById('console');
            }

            clear() {
                this.console.innerHTML = '';
            }

            logError(msg) {
                this.console.innerHTML += `<div style="color: #ff4444">[Ошибка] ${msg}</div>`;
            }
        }

        class Interpreter {
            constructor() {
                this.blocks = [];
                this.oneBlocks = new Map();
                this.currentBlock = null;
                this.currentOneBlock = null;
                this.errors = new ErrorSystem();
                this.lines = [];
                this.currentLine = 0;
            }

            async execute(code) {
                this.errors.clear();
                try {
                    this.lines = code.split('\n').filter(l => l.trim() !== '');
                    if (!this.lines[this.lines.length-1].startsWith('end)')) {
                        throw new Error('Отсутствует завершающий "end)"');
                    }

                    this.currentLine = 0;
                    while (this.currentLine < this.lines.length) {
                        await this.parseLine(this.lines[this.currentLine].trim());
                        this.currentLine++;
                    }
                } catch (e) {
                    this.errors.logError(e.message);
                }
            }

            async parseLine(line) {
                if (line.startsWith('add - block')) {
                    this.currentBlock = new Block();
                    this.blocks.push(this.currentBlock);
                }
                else if (line.startsWith('add - one.block(')) {
                    const match = line.match(/add - one.block\((\d+)\)/);
                    if (!match) throw new Error('Неправильный формат создания one.block');
                    const number = parseInt(match[1]);
                    if (this.oneBlocks.has(number)) throw new Error(`Блок ${number} уже существует`);
                    const oneBlock = new OneBlock(number);
                    this.oneBlocks.set(number, oneBlock);
                    this.currentOneBlock = oneBlock;
                }
                else if (line.startsWith('block.move.out')) {
                    const match = line.match(/block\.move\.out\((-?\d+),\s*(-?\d+)\)/);
                    if (!match || !this.currentBlock) throw new Error('Неправильный формат move.out');
                    await this.currentBlock.moveOut(parseInt(match[1]), parseInt(match[2]));
                }
                else if (line.startsWith('one.block.position(')) {
                    const match = line.match(/one\.block\.position\((\d+),\s*(\d+)\)/);
                    if (!match || !this.currentOneBlock) throw new Error('Неправильный формат позиции');
                    this.currentOneBlock.setPosition(parseInt(match[1]), parseInt(match[2]));
                }
                else if (line.startsWith('one.block.color(')) {
                    const match = line.match(/one\.block\.color\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (!match || !this.currentOneBlock) throw new Error('Неправильный формат цвета');
                    this.currentOneBlock.setColor(match[1], match[2], match[3]);
                }
                else if (line.startsWith('block.color(')) {
                    const match = line.match(/block\.color\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (!match || !this.currentBlock) throw new Error('Неправильный формат цвета блока');
                    this.currentBlock.setColor(match[1], match[2], match[3]);
                }
                else if (line.startsWith('if - block.move = ')) {
                    await this.handleIfCondition(line);
                }
                else if (line.startsWith('wait - ')) {
                    const seconds = parseFloat(line.split('wait - ')[1]);
                    await new Promise(resolve => setTimeout(resolve, seconds * 1000));
                }
                else if (line === 'end)') return;
                else throw new Error(`Неизвестная команда: ${line}`);
            }

            async handleIfCondition(line) {
                const match = line.match(/if - block\.move = \s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)/);
                if (!match) throw new Error('Неправильный формат условия if');
                
                const [_, targetDx, targetDy] = match;
                const lastMove = this.currentBlock.lastMove;

                if (lastMove.dx == targetDx && lastMove.dy == targetDy) {
                    this.currentLine++;
                    while (this.currentLine < this.lines.length) {
                        const currentLine = this.lines[this.currentLine].trim();
                        if (currentLine.startsWith('do ')) {
                            const action = currentLine.replace('do ', '');
                            await this.parseLine(action);
                        }
                        else if (currentLine.startsWith('end)')) break;
                        this.currentLine++;
                    }
                }
            }
        }

        const interpreter = new Interpreter();
        document.getElementById('runBtn').addEventListener('click', () => {
            document.getElementById('blocks').innerHTML = '';
            interpreter.execute(editor.getValue());
        });
    </script>
</body>
</html>
            
