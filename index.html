<!DOCTYPE html>
<html>
<head>
    <title>BlockLang IDE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/codemirror.min.css">
    <style>
        body { margin: 0; padding: 20px; font-family: Arial; }
        #editor-container { margin-bottom: 10px; }
        #editor { border: 2px solid #ccc; height: 200px; }
        #runBtn { padding: 30px 25px; background: #4CAF50; color: white; border: none; cursor: pointer; margin-top: 5px; }
        #output { border: 1px solid #ccc; padding: 10px; min-height: 300px; position: relative; }
        .block { width: 50px; height: 50px; background: #2196F3; position: absolute; transition: all 1s ease; }
        .one-block { border: 2px solid #000; }
        #console { margin-top: 20px; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; min-height: 100px; }
        .error { color: #ff4444; }
        .log { color: #333; }
    </style>
</head>
<body>
    <h1>BlockLang IDE</h1>
    <div id="editor-container">
        <div id="editor"></div>
        <button id="runBtn">▶ Запустить</button>
    </div>
    <div id="output">
        <div id="blocks"></div>
        <div id="console"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.0/mode/clike/clike.min.js"></script>
    <script>
        const editor = CodeMirror(document.getElementById('editor'), {
            mode: 'text/x-csrc',
            lineNumbers: true,
            theme: 'default',
            value: `add - block
block.color(100, 200, 50)
block.move.out(100, 100)
add - one.block(1)
one.block.position(40, 10)
one.block.color(255, 200, 0)

if - block.touched(one.block(1))
do script = return
end)`
        });

        class Block {
            constructor() {
                this.element = document.createElement('div');
                this.element.className = 'block';
                this.x = 0;
                this.y = 0;
                this.lastMove = { dx: 0, dy: 0 };
                this.updatePosition();
                document.getElementById('blocks').appendChild(this.element);
            }

            updatePosition() {
                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            async moveOut(dx, dy, duration = 1) {
                this.lastMove = { dx, dy };
                this.x += dx;
                this.y += dy;
                this.element.style.transition = `all ${duration}s ease`;
                this.updatePosition();
                return new Promise(resolve => setTimeout(resolve, duration * 1000));
            }

            setColor(r, g, b) {
                const valid = [r, g, b].every(n => n >=0 && n <= 255);
                if (!valid) throw new Error('Цвет должен быть в диапазоне 0-255');
                this.element.style.backgroundColor = `rgb(${r},${g},${b})`;
            }

            isTouching(otherBlock) {
                const rect1 = this.element.getBoundingClientRect();
                const rect2 = otherBlock.element.getBoundingClientRect();
                return !(
                    rect1.right < rect2.left || 
                    rect1.left > rect2.right || 
                    rect1.bottom < rect2.top || 
                    rect1.top > rect2.bottom
                );
            }
        }

        class OneBlock {
            constructor(number) {
                this.number = number;
                this.element = document.createElement('div');
                this.element.className = 'block one-block';
                this.x = 0;
                this.y = 0;
                this.updatePosition();
                document.getElementById('blocks').appendChild(this.element);
            }

            updatePosition() {
                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                this.updatePosition();
            }

            setColor(r, g, b) {
                const valid = [r, g, b].every(n => n >=0 && n <= 255);
                if (!valid) throw new Error('Цвет должен быть в диапазоне 0-255');
                this.element.style.backgroundColor = `rgb(${r},${g},${b})`;
            }
        }

        class Interpreter {
            constructor() {
                this.blocks = [];
                this.oneBlocks = new Map();
                this.currentBlock = null;
                this.currentOneBlock = null;
                this.lines = [];
                this.currentLine = 0;
                this.shouldReturn = false;
            }

            log(message, isError = false) {
                const consoleElem = document.getElementById('console');
                const msgElem = document.createElement('div');
                msgElem.className = isError ? 'error' : 'log';
                msgElem.textContent = message;
                consoleElem.appendChild(msgElem);
            }

            clearOutput() {
                document.getElementById('blocks').innerHTML = '';
                document.getElementById('console').innerHTML = '';
            }

            async execute(code) {
                this.clearOutput();
                this.lines = code.split('\n').filter(l => l.trim() !== '');
                this.shouldReturn = false;

                try {
                    if (!this.lines[this.lines.length-1].startsWith('end)')) {
                        throw new Error('Отсутствует завершающий "end)"');
                    }

                    for (this.currentLine = 0; this.currentLine < this.lines.length; this.currentLine++) {
                        if (this.shouldReturn) break;
                        await this.parseLine(this.lines[this.currentLine].trim());
                    }
                } catch (e) {
                    this.log(`[Ошибка] ${e.message}`, true);
                }
            }

            async parseLine(line) {
                try {
                    if (this.shouldReturn) return;

                    if (line.startsWith('add - block')) {
                        this.currentBlock = new Block();
                        this.blocks.push(this.currentBlock);
                    }
                    else if (line.startsWith('add - one.block(')) {
                        const match = line.match(/add - one.block\((\d+)\)/);
                        if (!match) throw new Error('Неправильный формат создания one.block');
                        
                        const number = parseInt(match[1]);
                        if (this.oneBlocks.has(number)) {
                            throw new Error(`Блок с номером ${number} уже существует`);
                        }
                        
                        const oneBlock = new OneBlock(number);
                        this.oneBlocks.set(number, oneBlock);
                        this.currentOneBlock = oneBlock;
                    }
                    else if (line.startsWith('block.move.out(')) {
                        const match = line.match(/block\.move\.out\((-?\d+),\s*(-?\d+)\)/);
                        if (!match || !this.currentBlock) throw new Error('Неправильный формат move.out');
                        
                        await this.currentBlock.moveOut(
                            parseInt(match[1]), 
                            parseInt(match[2])
                        );
                    }
                    else if (line.startsWith('one.block.position(')) {
                        const match = line.match(/one\.block\.position\((-?\d+),\s*(-?\d+)\)/);
                        if (!match || !this.currentOneBlock) throw new Error('Неправильный формат позиции');
                        
                        this.currentOneBlock.setPosition(
                            parseInt(match[1]), 
                            parseInt(match[2])
                        );
                    }
                    else if (line.startsWith('one.block.color(')) {
                        const match = line.match(/one\.block\.color\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (!match || !this.currentOneBlock) throw new Error('Неправильный формат цвета');
                        
                        this.currentOneBlock.setColor(
                            parseInt(match[1]), 
                            parseInt(match[2]), 
                            parseInt(match[3])
                        );
                    }
                    else if (line.startsWith('block.color(')) {
                        const match = line.match(/block\.color\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (!match || !this.currentBlock) throw new Error('Неправильный формат цвета блока');
                        
                        this.currentBlock.setColor(
                            parseInt(match[1]), 
                            parseInt(match[2]), 
                            parseInt(match[3])
                        );
                    }
                    else if (line.startsWith('if - block.touched(')) {
                        const match = line.match(/if - block\.touched\(one\.block\((\d+)\)\)/);
                        if (!match || !this.currentBlock) throw new Error('Неправильный формат условия touched');
                        
                        const blockNumber = parseInt(match[1]);
                        const oneBlock = this.oneBlocks.get(blockNumber);
                        if (!oneBlock) throw new Error(`OneBlock ${blockNumber} не существует`);
                        
                        if (this.currentBlock.isTouching(oneBlock)) {
                            this.currentLine++;
                            while (this.currentLine < this.lines.length) {
                                const currentLine = this.lines[this.currentLine].trim();
                                if (currentLine.startsWith('do script = return')) {
                                    this.shouldReturn = true;
                                    break;
                                }
                                else if (currentLine.startsWith('end)')) break;
                                this.currentLine++;
                            }
                        }
                    }
                    else if (line === 'end)') {
                        return;
                    }
                    else {
                        throw new Error(`Неизвестная команда: "${line}"`);
                    }
                } catch (e) {
                    throw new Error(`Строка ${this.currentLine + 1}: ${e.message}`);
                }
            }
        }

        const interpreter = new Interpreter();
        document.getElementById('runBtn').addEventListener('click', () => {
            interpreter.execute(editor.getValue());
        });
    </script>
</body>
</html>
